---
link: https://www.notion.so/R23-02-23-6e7dec48359f4be982bbf266084ad870
notionID: 6e7dec48-359f-4be9-82bb-f266084ad870
---
#46
##### I/O Throttling 구현 테스트 세팅
- Qemu에 수정한 커널을 실행하는 구현을 세팅 후, 테스트 스크립트를 구현함
- ftrace의 events 중 writeback의 balance_dirty_pages를 프로파일링 해가지고, 수정한 코드가 backgroud ratio, hardlimit, setpoint들을 어떻게 변화시키는지 확인해보고자 했음.
- 그러나 세팅 후 테스트 결과 트레이싱 되어야 하는 환경임에도 불구하고(write 버퍼로 인해 메모리가 꽉참), 트레이스에 잡히지 않는다.
- **왜?**

#47
##### I/O Throttling의 setpoint 증감에 대한 구상
- Setpoint를 늘린다.
	1. 지금 새로 생성하려는 page가 recency가 제일 높다. 그걸 최대한 덜 쉬고 받아들일 수 있도록 해준다.
		- 근데 사실 Linux 정책상 무조건 제일 높지는 않다. once used일수도 있어서 처음 생성은 inactive에 넣기 때문이다.
	2. Setpoint를 늘리는 부수효과로 당장에 Freerun을 늘려서 sleep을 없앤다.
- Setpoint를 줄인다.
	1. 다른 어플리케이션에 미치는 피해를 줄인다.
		- 그 피해는 왜, 어떻게 생기는건데? 어차피 나는 더럽힌다는 차이만 있을 뿐, 너가 쓰는 메모리랑 내가 쓰는 메모리랑 도대체 뭔 차이가 있다고 그래?
		1. 백그라운드가 write 작업을 수행해 주어야 한다는 추가적인 작업이 생긴다.
		2. 무차별적인 random write를 피하기 위해 기회를 한 번 더 주느라 페이지 회수가 지연된다.

- 그래서 위와 같이 정리하면 뭐 어떻게 결론 지을 수 있는가
	- Sleep이 생기면 늘린다. => Freerun을 늘려서 sleep을 없애 성능을 증가시킨다.
	- Dirty reclaim 시도가 있다면 줄인다는 점. => 페이지 회수가 지연되어 다른 어플리케이션의 성능을 방해하지 않도록 dirty page 수를 줄인다.
	- 그러나 dirty reclaim시도가 active였던적이 있는 애라면 조금 덜 줄여야한다. => 어라? dirty로 쓰이는 애들이 은근 active로 쓰이는 놈들이네?

- 어떠한 상황인지는 정해졌는데 얼마만큼일 때 얼마를 증감할지를 정해야 한다.
	- 일단은 실험 값을 토대로 임의로 정해본다.
	- 늘릴 때: 당장에 recency를 고려해주기는 어렵다. freerun의 효과를 노린다. 따라서 현재 dirty수를 보고 freerun이 그것보다는 커지도록 늘리는데, 여유를 좀 더 줘서 늘린다. 그 때의 여유는 현재 freerun과의 차이만큼의 1.5배만큼.
		- 여유의 근거: 현재 재우려고 하는 상황이 freerun을 넘긴 첫 상황. 바로 직전 상황이 freerun 직전이라고 가정했을 때, 현재의 속도는 freerun과의 차이만큼이라고 할 수 있다. 따라서 그 크기의 일정 배수만큼 크게 늘려서 바로 순간적으로 증가시킨 freerun을 넘는 상황을 방지한다.
	- 줄일 때: nr_scanned 대비 nr_dirty 수를 사용. 50% 미만일 때는 그 값의 1/2 퍼센트 만큼만 줄이고, 50%이상일 때는 딱 그 퍼센트만큼 줄인다. 다만 active->inactive인 애는 dirty의 카운트에서 제외한다.
		- 50% 숫자의 이유: reclaim시 nr_dirty수가 절반 이상일 때 그 다음부터 우후죽순 dirty가 나타나기 시작한다.
		- active->inactive였던 애를 카운트에서 제거하는 이유: dirty인 애가 생각보다 active하게 사용되고 있구나 좀 늘려주어야 겠다~라는 의미

- 위와 같은 디자인은 결국 fluctuation을 막고, 특정한 때 평형 상태가 될 수 있도록 하는 장치가 있어야 한다.
	- 일단은 그러한 장치 없이 위와 같이 했을 때를 구현해서 성능을 본다.
